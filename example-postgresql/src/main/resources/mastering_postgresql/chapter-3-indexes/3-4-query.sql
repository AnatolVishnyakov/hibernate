-----------------------
-- Clustering tables --
-----------------------

-- В PostgreSQL есть команда CLUSTER, которая позволяет
-- нам переписать таблицу в желаемом порядке. Можно
-- указать на индекс и хранить данные в том же порядке,
-- что и индекс:

-- Команда CLUSTER заблокирует таблицу во время ее работы.
-- Вы не можете вставлять или изменять данные во время
-- работы CLUSTER. Это может быть неприемлемо в производственной системе.

-- Данные могут быть организованы только по одному индексу.

-- На самом деле разница в производительности между кластеризованной
-- и некластеризованной таблицей будет зависеть от рабочей нагрузки,
-- объема извлекаемых данных, частоты попаданий в кеш и многого другого.

 -- Кластерное состояние таблицы не будет поддерживаться,
 -- поскольку изменения вносятся в таблицу во время обычных
 -- операций. Со временем корреляция обычно ухудшается.
CLUSTER t_random USING idx_random;

EXPLAIN (analyze true, buffers true, timing true)
SELECT * FROM t_random WHERE id < 10000;

------------------------------------
-- Making use of index only scans --
------------------------------------

EXPLAIN ANALYSE SELECT * FROM t_test WHERE id = 34234;
-- Index Scan using idx_id on t_test  (cost=0.43..8.45 rows=1 width=9) (actual time=0.015..0.016 rows=1 loops=1)
-- Index Cond: (id = 34234)
-- Planning time: 0.078 ms
-- Execution time: 0.027 ms

-- Здесь нет ничего необычного. PostgreSQL использует
-- индекс для поиска одной строки. Что произойдет,
-- если выбран только один столбец?

EXPLAIN ANALYSE SELECT id FROM t_test WHERE id = 34234;
-- Index Only Scan using idx_id on t_test  (cost=0.43..8.45 rows=1 width=4) (actual time=0.016..0.016 rows=1 loops=1)
--   Index Cond: (id = 34234)
--   Heap Fetches: 1
-- Planning time: 0.081 ms
-- Execution time: 0.030 ms

-- ЕСЛИ ДАННЫЕ ЕСТЬ В ИНДЕКСЕ, В ТАБЛИЦУ НЕ ЛЕЗЕМ, ИЗВЛЕКАЕМ ИЗ ИНДЕКСА.
-- Как видите, план изменился с Index Scan на Index Only Scan.
-- В нашем примере столбец id был проиндексирован, поэтому его
-- содержимое, естественно, находится в индексе. В большинстве
-- случаев нет необходимости переходить к таблице, если все
-- данные уже можно извлечь из индекса.
-- Переход к таблице требуется только в том случае, если
-- запрашиваются дополнительные поля, чего здесь нет.
-- Следовательно, Index Only Scan обещает значительно
-- лучшую производительность, чем Index Scan.

----------------------------------------------
-- Understanding additional b-tree features --
----------------------------------------------

-- В PostgreSQL индексирование - это обширная область,
-- охватывающая многие аспекты работы с базами данных.
-- Индексация - это ключ к производительности.
-- Без правильной индексации нет хорошей производительности.

-- Combined indexes (комбинированные индексы)
-- В чем разница между комбинированным и индивидуальным индексом?
-- Общее правило заключается в том, что если один индекс
-- может решить задачу, используйте инд. индекс.
-- Однако вы не можете проиндексировать все возможные
-- комбинации полей, по которым происходит фильтрация.
-- Что вы можете сделать, так это использовать свойства
-- комбинированных индексов для достижения максимально
-- возможного выигрыша.

-- Предположим, у нас есть таблица, содержащая
-- три столбца: postal_code, last_name, first_name.
-- (имеем индекс по этим трем полям postal_code__last_name__first_name)

-- Идеальный вариант для попадания индекса
-- postal_code = 2700 AND
-- last_name = 'Schönig' AND
-- first_name = 'Hans'

-- Попадание в индекс
-- postal_code = 2700 AND
-- last_name = 'Schönig'

-- Попадание в индекс, PostgreSQL
-- просто поменяет условия местами.
-- last_name = 'Schönig AND
-- postal_code = 2700

-- Это похоже на инд. индекс для postal_code;
-- Попадание в индекс, комбинированному индексу
-- просто нужно больше места на диске.
-- postal_code = 2700

-- Не попадание в индекс.
-- PostgreSQL будет сканировать весь индекс, если
-- это дешевле, чтения всей таблицы.
-- first_name = 'Hans'