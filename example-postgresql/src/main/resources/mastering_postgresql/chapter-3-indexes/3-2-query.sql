-----------------------------------------
-- Using more than one index at a time --
-----------------------------------------

-- PostgreSQL позволяет использовать несколько
-- индексов в одном запросе. Конечно, это имеет смысл,
-- если одновременно запрашиваются несколько столбцов.
-- Однако это не всегда так. Также может случиться так,
-- что один индекс используется несколько раз для
-- обработки одного и того же столбца.
explain analyse
SELECT *
FROM t_test
WHERE id = 30
   OR id = 50;
-- Bitmap - это метод сканирования.
-- Идея Bitmap сканирования заключается в том,
-- что PostgreSQL будет сканировать первый индекс,
-- собирая список блоков, содержащих данные. Затем
-- будет просканирован следующий индекс, чтобы снова
-- составить список блоков. Это работает для любого
-- количества индексов. В случае OR эти списки затем
-- будут объединены, в результате чего останется большой
-- список блоков, содержащих данные. Используя этот список,
-- таблица будет просканирована для извлечения этих блоков.

-- Проблема в том, что PostgreSQL получил намного больше
-- данных, чем нужно. В нашем случае запрос будет искать
-- две строки; однако Bitmap сканирование вернет пару блоков.
-- Следовательно, исполнитель выполнит повторную проверку,
-- чтобы отфильтровать эти строки, не удовлетворяющие нашим условиям.

------------------------------------
-- Using bitmap scans effectively --
------------------------------------

-- Возникает естественный вопрос:
--  когда Bitmap сканирование наиболее полезно,
--  а когда его выбирает оптимизатор? С моей точки зрения,
--  есть только два варианта использования:
--      1. Для избежания использования одного и того же блока снова и снова.
--      2. Когда сочетаются относительно плохие условия.

-- Первый случай довольно распространен.
-- Предположим, вы ищете всех, кто говорит
-- на определенном языке. В качестве примера можно
-- предположить, что 10% всех людей говорят на
-- требуемом языке. Сканирование индекса будет означать,
-- что блок в таблице придется сканировать заново,
-- поскольку в одном блоке может храниться много
-- квалифицированных ораторов. Применение Bitmap сканирования
-- гарантирует, что конкретный блок используется только один раз,
-- что, конечно, приводит к повышению производительности.

-- Второй распространенный вариант использования -
-- совместное использование относительно слабых критериев поисква.
-- Предположим, мы ищем всех в возрасте от 20 до 30 лет с желтой
-- рубашкой. Сейчас, может быть, 15% всех людей в возрасте
-- от 20 до 30 лет, а может быть, 15% всех людей действительно владеют
-- желтой рубашкой. Последовательное сканирование таблицы является
-- дорогостоящим, поэтому PostgreSQL может решить выбрать два индекса,
-- поскольку конечный результат может состоять всего из 1% данных.
-- Сканирование обоих индексов может быть дешевле, чем чтение всех данных.

-----------------------------------------
-- Using indexes in an intelligent way --
-----------------------------------------

CREATE INDEX idx_name ON t_test (name);

EXPLAIN ANALYSE
SELECT *
FROM t_test
WHERE name = 'hans2';

EXPLAIN ANALYSE
SELECT *
FROM t_test
WHERE name = 'hans'
   OR name = 'paul';
-- Planning time: 0.088 ms
-- Execution time: 860.881 ms

-- В этом случае PostgreSQL выполнит прямое последовательное
-- сканирование. Это почему? Почему система игнорирует все
-- индексы? Причина проста; hans и paul составляют весь набор
-- данных, потому что других значений нет (PostgreSQL знает это,
-- проверяя системную статистику). Таким образом, PostgreSQL считает,
-- что в любом случае необходимо прочитать всю таблицу. Нет причин
-- читать весь индекс и всю таблицу, если достаточно чтения только таблицы.

EXPLAIN ANALYSE
SELECT *
FROM t_test
WHERE name = 'hans2'
   OR name = 'paul2';
-- Planning time: 0.134 ms
-- Execution time: 0.096 ms

-- Здесь наиболее важно усвоить то, что планы
-- выполнения зависят от входных значений.
-- Они не статичны и не зависят от данных внутри
-- таблицы. Это очень важное наблюдение, о котором
-- нужно постоянно помнить. В реальных примерах факт
-- изменения планов часто может быть причиной
-- непредсказуемого времени выполнения.