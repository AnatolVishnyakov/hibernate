--------------------------------------------
-- Improving speed using clustered tables --
--------------------------------------------

EXPLAIN (analyze true, buffers true, timing true)
SELECT *
FROM t_test
WHERE id < 10000;

-- Это лучший способ выяснить, правильно ли разработал
-- планировщик запрос или нет. Параметр buffers true сообщит
-- нам, сколько блоков размером 8k было затронуто запросом.
-- В этом примере было затронуто всего 85 блоков. Совместное
-- попадание означает, что данные поступали из кеша ввода-вывода
-- PostgreSQL (общий буфер).

-- Что произойдет, если данные в вашей таблице
-- несколько случайны? Что-нибудь изменится?
CREATE TABLE t_random AS SELECT * FROM t_test ORDER BY random();

-- Чтобы обеспечить справедливое сравнение, индексируется один
-- и тот же столбец:
CREATE INDEX idx_random ON t_random (id);

-- Для правильной работы PostgreSQL потребуется статистика оптимизатора.
-- Эти статистические данные сообщают PostgreSQL, сколько существует
-- данных, как распределяются значения и соотносятся ли данные на диске.
VACUUM ANALYZE t_random;

EXPLAIN (analyze true, buffers true, timing true)
SELECT * FROM t_random WHERE id < 10000;
-- Bitmap Heap Scan on t_random  (cost=176.74..17275.36 rows=9330 width=9) (actual time=2.485..8.703 rows=9999 loops=1)
--   Recheck Cond: (id < 10000)
--   Heap Blocks: exact=8014
--   Buffers: shared hit=8044
--   ->  Bitmap Index Scan on idx_random  (cost=0.00..174.41 rows=9330 width=0) (actual time=1.443..1.443 rows=9999 loops=1)
--         Index Cond: (id < 10000)
--         Buffers: shared hit=30
-- Planning time: 0.110 ms
-- Execution time: 9.350 ms

-- Здесь есть пара вещей, на которые стоит обратить внимание.
-- Прежде всего, потребовалось ошеломляющее количество блоков в 8 044,
-- а время выполнения взлетело до более 9 миллисекунд. Единственное,
-- что несколько улучшило производительность, это то, что данные снова
-- поступали из памяти, а не с диска. Только представьте, что бы это значило,
-- если бы вам пришлось обращаться к диску 8044 раза только для того, чтобы
-- ответить на этот запрос. Это было бы полной катастрофой, потому что ожидание
-- диска, безусловно, резко замедлило бы работу.


-- Как планировщик узнает, как данные хранятся на диске?
-- pg_stats - это системное представление, содержащее всю статистику
-- о содержимом столбцов. Следующий запрос показывает релевантное
-- содержание:
SELECT tablename, attname, correlation
FROM pg_stats
WHERE tablename IN ('t_test', 't_random')
ORDER BY 1, 2;
------------------------------------------
-- tablename    attname     correlation --
------------------------------------------
-- t_random,    id,         0.00520872
-- t_random,    name,       0.5034781
-- t_test,      id,         1
-- t_test,      name,       1
------------------------------------------

-- Как видите, PostgreSQL заботится о каждом столбце.
-- Содержимое представления создается функцией ANALYZE,
-- которая жизненно важна для производительности.
-- Обычно ANALYZE автоматически выполняется в фоновом режиме
-- с помощью демона autovacuum.

-- Почему это приводит к тому, что запрос попадает в
-- такое количество блоков? Ответ относительно прост.
-- Если данные, которые нам нужны, не упакованы вместе,
-- а равномерно распределены по таблице, для извлечения
-- того же объема информации потребуется больше блоков,
-- что, в свою очередь, приведет к снижению производительности.

